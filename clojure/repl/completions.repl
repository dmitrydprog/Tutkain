(ns repl.completions
  (:require
   [clojure.set :as set]
   [clojure.spec.alpha :as spec]
   [clojure.spec.test.alpha :as test]
   [clojure.test.check :as tc]
   [clojure.test.check.generators :as gen]
   [clojure.test.check.properties :as prop]
   [cognitect.transcriptor :as xr]
   [tutkain.repl.runtime.completions :as completions :refer [candidates]]))

;; Specs

(spec/def ::candidate string?)
(spec/def ::type #{:keyword :var :function :static-method :macro :special-form :namespace :class :method})

(spec/def ::completion
  (spec/keys :req-un [::candidate ::type]))

(spec/def ::completions (spec/nilable (spec/coll-of ::completion :kind sequential? :distinct true)))

;; Tests

(candidates "" *ns*)
(xr/check! empty?)

(candidates ":a" 'clojure.core)
(xr/check! ::completions)

(tc/quick-check 100
  (prop/for-all [kw gen/keyword]
    (let [prefix (subs (str kw) 0 2)
          completion-set (set (candidates prefix *ns*))]
      (contains? completion-set {:candidate (str kw) :type :keyword}))))

(spec/def ::arglists (spec/coll-of string?))
(spec/def ::doc string?)

(spec/def ::symbol-completion
  (spec/merge ::completion (spec/keys :opt-un [::arglists ::doc])))

(spec/def ::symbol-completions
  (spec/coll-of ::symbol-completion :kind sequential?))

(candidates "a" 'clojure.core)
(xr/check! ::symbol-completions)

(def sym-names
  (sequence
    (comp
      (mapcat ns-publics)
      (map (comp str first)))
    (all-ns)))

(def sym-candidates
  (mapcat #(candidates (subs % 0 1) *ns*) sym-names))

(xr/check! ::symbol-completions sym-candidates)

(assert (set/subset? #{{:candidate "java.util.ArrayList" :type :class}
                       {:candidate "java.util.Date" :type :class}}
          (set (candidates "java.u" *ns*))))

(assert (not-any? #(.contains (:candidate %) "$") (candidates "java." *ns*)))

(assert (set/subset? #{{:candidate "java.time.LocalDate/parse" :type :static-method}
                       {:candidate "java.time.LocalDate/DAYS_PER_CYCLE" :type :static-method}}
          (set (candidates "java.time.LocalDate/" *ns*))))

(let [imported-classes (set (map second (mapcat ns-imports (all-ns))))]
  (mapcat #(candidates (str (.getName %) "/") *ns*) imported-classes))

(xr/check! (spec/coll-of ::completion :min-count 1))

(xr/check! ::completions (candidates ".g" *ns*))
(candidates "java.util.Date/" *ns*)

(xr/check! ::completions (candidates "java.util.Spliterator$" *ns*))
(assert (every? #(.contains (:candidate %) "$") (candidates "java.util.Spliterator$" *ns*)))

(spec/def ::function-completion
  (spec/keys :req-un [::candidate ::type ::arglists] :opt-un [::doc]))

(spec/def ::function-completions
  (spec/coll-of ::function-completion :kind sequential? :min-count 1))

(xr/check! ::function-completions (filter (comp #{:function} :type) sym-candidates))

(spec/def ::prefix
  (spec/with-gen string? (constantly (gen/fmap str gen/symbol))))

(spec/def ::ns
  (spec/with-gen (partial instance? clojure.lang.Namespace) #(gen/elements (all-ns))))

(spec/fdef completions/completions
  :args (spec/cat :prefix ::prefix :ns ::ns)
  :ret ::completions)

(spec/exercise-fn `completions/completions)

(->>
  (test/check `completions/completions)
  (test/summarize-results))

(xr/check! #{{:total 1 :check-passed 1}})
